<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Processor - US Letter Format</title>
    <style>
        /* Page setup for US Letter (8.5" x 11") */
        @page {
            size: letter;
            margin: 1in;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* Page container wrapper */
        .page-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .document-container {
            /* US Letter dimensions - FIXED SIZE */
            width: 8.5in;
            height: 11in;
            min-height: 11in;
            max-height: 11in;
            
            /* Standard 1 inch margins */
            padding: 1in;
            box-sizing: border-box;
            
            /* Visual styling */
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            
            /* Page-like appearance */
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }
        
        /* Margin indicators */
        .margin-guides {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .show-margins .margin-guides {
            opacity: 1;
        }
        
        .margin-guides::before {
            content: '';
            position: absolute;
            top: 1in;
            left: 1in;
            right: 1in;
            bottom: 1in;
            border: 1px dashed #ccc;
        }
        
        /* Page info display */
        .page-info {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 3px;
            z-index: 10;
        }
        
        /* Page break visual indicator */
        .document-container + .document-container {
            margin-top: 20px;
        }
        
        /* Print styles */
        @media print {
            body {
                background: white;
                padding: 0;
            }
            
            .toolbar,
            .format-buttons,
            .page-info,
            #status {
                display: none !important;
            }
            
            .document-container {
                box-shadow: none;
                margin: 0;
                page-break-after: always;
                break-after: page;
            }
            
            .document-container:last-child {
                page-break-after: auto;
            }
            
            .margin-guides {
                display: none !important;
            }
        }
        .toolbar {
            position: sticky;
            top: 0;
            background: #333;
            color: white;
            padding: 10px 20px;
            width: 100%;
            max-width: 8.5in;
            display: flex;
            gap: 10px;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border-radius: 4px 4px 0 0;
            margin-bottom: 0;
        }
        .toolbar button {
            background: #555;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        .toolbar button:hover {
            background: #666;
        }
        .editable-content {
            /* Content area = 6.5" x 9" (after 1" margins) */
            width: 100%;
            height: 9in;
            min-height: 9in;
            max-height: 9in;
            line-height: 2; /* Default double-spaced */
            outline: none;
            overflow: hidden;
            font-size: 12pt;
            position: relative;
            box-sizing: border-box;
        }
        .editable-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px 0;
        }
        
        /* Text alignment classes */
        .editable-content [style*="text-align: left"] {
            text-align: left !important;
        }
        
        .editable-content [style*="text-align: center"] {
            text-align: center !important;
        }
        
        .editable-content [style*="text-align: right"] {
            text-align: right !important;
        }
        
        /* Ensure alignment is preserved in print */
        @media print {
            [style*="text-align"] {
                text-align: inherit !important;
            }
        }
        
        /* Table of Contents styles */
        .table-of-contents {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 20px;
            margin: 20px 0;
            page-break-inside: avoid;
        }
        
        .table-of-contents h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18pt;
            text-align: center;
            color: #333;
        }
        
        .toc-entry {
            display: flex;
            align-items: baseline;
            margin-bottom: 8px;
            position: relative;
        }
        
        .toc-entry.toc-level-1 {
            font-weight: bold;
            margin-top: 10px;
        }
        
        .toc-entry.toc-level-2 {
            margin-left: 20px;
        }
        
        .toc-entry.toc-level-3 {
            margin-left: 40px;
            font-size: 0.9em;
        }
        
        .toc-title {
            flex: 0 0 auto;
            max-width: 80%;
            padding-right: 10px;
        }
        
        .toc-dots {
            flex: 1 1 auto;
            border-bottom: 1px dotted #999;
            margin: 0 5px;
            min-width: 20px;
            height: 0.8em;
        }
        
        .toc-page {
            flex: 0 0 auto;
            padding-left: 10px;
            font-weight: normal;
        }
        
        .toc-link {
            color: #0066cc;
            text-decoration: none;
        }
        
        .toc-link:hover {
            text-decoration: underline;
        }
        
        .toc-update-notice {
            font-size: 0.8em;
            color: #666;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        .image-container {
            position: relative;
            display: inline-block;
        }
        .image-container .image-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: none;
            gap: 5px;
        }
        .image-container:hover .image-controls {
            display: flex;
        }
        .image-controls button {
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .format-buttons {
            margin: 10px 0;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            max-width: 8.5in;
            background: white;
            padding: 10px;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .format-buttons button {
            padding: 5px 10px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 3px;
        }
        .format-buttons button:hover {
            background: #f0f0f0;
        }
        
        .format-buttons span {
            display: inline-flex;
            align-items: center;
        }
        #status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
    <div class="toolbar">
        <button onclick="saveDocument()">üíæ Save</button>
        <button onclick="loadDocument()">üìÅ Load</button>
        <button onclick="exportAsHTML()">üì§ Export HTML</button>
        <button onclick="exportAsMarkdown()">üìù Export Markdown</button>
        <button onclick="insertImage()">üñºÔ∏è Insert Image</button>
        <button onclick="insertTable()">üìä Insert Table</button>
        <button onclick="insertTOC()">üìë Insert TOC</button>
        <button onclick="toggleEditMode()">‚úèÔ∏è Toggle Edit</button>
        <button onclick="toggleMargins()">üìè Toggle Margins</button>
        <button onclick="addNewPage()">üìÑ Add Page</button>
    </div>

    <div class="format-buttons">
        <button onclick="formatText('bold')"><b>Bold</b></button>
        <button onclick="formatText('italic')"><i>Italic</i></button>
        <button onclick="formatText('underline')"><u>Underline</u></button>
        <button onclick="formatText('h1')">H1</button>
        <button onclick="formatText('h2')">H2</button>
        <button onclick="formatText('h3')">H3</button>
        <button onclick="formatText('ul')">‚Ä¢ List</button>
        <button onclick="formatText('ol')">1. List</button>
        <button onclick="formatText('quote')">Quote</button>
        <button onclick="formatText('code')">Code</button>
        <button onclick="formatText('link')">üîó Link</button>
        <span style="border-left: 1px solid #ddd; margin: 0 5px; height: 20px;"></span>
        <button onclick="alignText('left')" title="Align Left">‚¨ÖÔ∏è Left</button>
        <button onclick="alignText('center')" title="Align Center">‚ÜîÔ∏è Center</button>
        <button onclick="alignText('right')" title="Align Right">‚û°Ô∏è Right</button>
        <span style="border-left: 1px solid #ddd; margin: 0 5px; height: 20px;"></span>
        <select id="lineSpacingSelect" onchange="setLineSpacing(this.value)" title="Line Spacing" style="padding: 5px 10px; border: 1px solid #ddd; background: white; cursor: pointer; border-radius: 3px;">
            <option value="1">Single</option>
            <option value="1.15">1.15</option>
            <option value="1.5">1.5</option>
            <option value="2" selected>Double</option>
            <option value="2.5">2.5</option>
            <option value="3">Triple</option>
        </select>
    </div>

    <div class="document-container" id="page-1">
        <div class="margin-guides"></div>
        <div class="page-info">Page 1 | US Letter (8.5" √ó 11")</div>
        <div id="document-content" class="editable-content" contenteditable="true" style="height: 9in; min-height: 9in; max-height: 9in;">
            <h1>Document Processing System</h1>
            <p>This is a fully editable document that Claude can control. You can:</p>
            <ul>
                <li>Edit text directly</li>
                <li>Insert and manage images</li>
                <li>Create tables</li>
                <li>Apply formatting</li>
                <li>Save and load documents</li>
                <li>Export to different formats</li>
            </ul>
            
            <h2>How to Use</h2>
            <p>1. Claude can read this entire document using the Read tool</p>
            <p>2. Claude can edit by using the Edit tool to modify the HTML file</p>
            <p>3. Images can be embedded as base64 or linked to local files</p>
            <p>4. The document maintains full formatting and structure</p>
            
            <h2>Example Table</h2>
            <table>
                <tr>
                    <th>Feature</th>
                    <th>Status</th>
                    <th>Notes</th>
                </tr>
                <tr>
                    <td>Text Editing</td>
                    <td>‚úÖ Full Support</td>
                    <td>Rich text with formatting</td>
                </tr>
                <tr>
                    <td>Image Management</td>
                    <td>‚úÖ Full Support</td>
                    <td>Insert, resize, delete</td>
                </tr>
                <tr>
                    <td>Tables</td>
                    <td>‚úÖ Full Support</td>
                    <td>Create and edit tables</td>
                </tr>
            </table>
        </div>
    </div>
    </div>

    <div id="status">Saved!</div>

    <script>
        let editMode = true;
        let showMargins = false;
        let pageCount = 1;
        let currentLineSpacing = 2; // Default double-spaced
        
        // Update toolbar state to show current formatting
        function updateToolbarState() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                let element = range.commonAncestorContainer;
                
                // Get parent element if we're in a text node
                if (element.nodeType === 3) {
                    element = element.parentElement;
                }
                
                // Find the line spacing of current element
                let lineHeight = null;
                let checkElement = element;
                
                while (checkElement && checkElement !== document.body) {
                    const computedStyle = window.getComputedStyle(checkElement);
                    const computedLineHeight = computedStyle.lineHeight;
                    
                    // Check if element has explicit line-height style
                    if (checkElement.style.lineHeight) {
                        lineHeight = parseFloat(checkElement.style.lineHeight);
                        break;
                    }
                    
                    // Check computed line-height (but only if it's not 'normal')
                    if (computedLineHeight !== 'normal') {
                        // Convert px values to multiplier
                        const fontSize = parseFloat(computedStyle.fontSize);
                        const lineHeightPx = parseFloat(computedLineHeight);
                        if (!isNaN(lineHeightPx) && !isNaN(fontSize) && fontSize > 0) {
                            lineHeight = lineHeightPx / fontSize;
                            break;
                        }
                    }
                    
                    checkElement = checkElement.parentElement;
                }
                
                // If no line height found, use the current default
                if (lineHeight === null) {
                    lineHeight = currentLineSpacing;
                }
                
                // Update the line spacing dropdown to show current value
                const spacingSelect = document.getElementById('lineSpacingSelect');
                if (spacingSelect) {
                    // Find closest matching option
                    const options = Array.from(spacingSelect.options);
                    let closestOption = options[0];
                    let closestDiff = Math.abs(parseFloat(closestOption.value) - lineHeight);
                    
                    options.forEach(option => {
                        const diff = Math.abs(parseFloat(option.value) - lineHeight);
                        if (diff < closestDiff) {
                            closestDiff = diff;
                            closestOption = option;
                        }
                    });
                    
                    // First, reset all option texts to their original values
                    options.forEach(option => {
                        const baseText = option.text.split(' (')[0]; // Remove any existing parentheses
                        option.text = baseText;
                    });
                    
                    // Update the label to show actual value if different
                    if (Math.abs(parseFloat(closestOption.value) - lineHeight) > 0.01) {
                        // Show actual value in parentheses
                        const originalText = closestOption.text.split(' (')[0]; // Remove any existing parentheses
                        closestOption.text = `${originalText} (${lineHeight.toFixed(2)})`;
                    }
                    
                    spacingSelect.value = closestOption.value;
                }
            }
        }
        
        // Update toolbar state on selection change
        document.addEventListener('selectionchange', updateToolbarState);
        
        // Update toolbar state on click
        document.addEventListener('click', function(e) {
            if (e.target.closest('.editable-content')) {
                setTimeout(updateToolbarState, 10);
            }
        });
        
        // Update toolbar state on keyboard navigation
        document.addEventListener('keyup', function(e) {
            if (e.target.closest('.editable-content')) {
                // Update on arrow keys, page up/down, home/end
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 
                     'PageUp', 'PageDown', 'Home', 'End'].includes(e.key)) {
                    setTimeout(updateToolbarState, 10);
                }
            }
        });

        function toggleEditMode() {
            editMode = !editMode;
            document.getElementById('document-content').contentEditable = editMode;
            showStatus(editMode ? 'Edit mode enabled' : 'View mode enabled');
        }

        function formatText(command) {
            switch(command) {
                case 'bold':
                    document.execCommand('bold', false, null);
                    break;
                case 'italic':
                    document.execCommand('italic', false, null);
                    break;
                case 'underline':
                    document.execCommand('underline', false, null);
                    break;
                case 'h1':
                    document.execCommand('formatBlock', false, '<h1>');
                    break;
                case 'h2':
                    document.execCommand('formatBlock', false, '<h2>');
                    break;
                case 'h3':
                    document.execCommand('formatBlock', false, '<h3>');
                    break;
                case 'ul':
                    document.execCommand('insertUnorderedList', false, null);
                    // Apply 1.5 spacing to new unordered lists
                    setTimeout(() => applyListSpacing(), 50);
                    break;
                case 'ol':
                    document.execCommand('insertOrderedList', false, null);
                    // Apply 1.5 spacing to new ordered lists
                    setTimeout(() => applyListSpacing(), 50);
                    break;
                case 'quote':
                    document.execCommand('formatBlock', false, '<blockquote>');
                    break;
                case 'code':
                    document.execCommand('formatBlock', false, '<pre>');
                    break;
                case 'link':
                    const url = prompt('Enter URL:');
                    if (url) document.execCommand('createLink', false, url);
                    break;
            }
            
            // Update toolbar after formatting
            updateToolbarState();
        }
        
        function applyListSpacing() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                let listElement = range.commonAncestorContainer;
                
                // Find the list element
                while (listElement && listElement.nodeType !== 1) {
                    listElement = listElement.parentElement;
                }
                
                while (listElement && listElement.nodeName !== 'UL' && listElement.nodeName !== 'OL') {
                    listElement = listElement.parentElement;
                }
                
                if (listElement && (listElement.nodeName === 'UL' || listElement.nodeName === 'OL')) {
                    // Only apply if the list doesn't already have a line-height set
                    if (!listElement.style.lineHeight) {
                        listElement.style.lineHeight = '1.5';
                    }
                }
            }
        }
        
        function alignText(alignment) {
            // Use execCommand for alignment
            switch(alignment) {
                case 'left':
                    document.execCommand('justifyLeft', false, null);
                    break;
                case 'center':
                    document.execCommand('justifyCenter', false, null);
                    break;
                case 'right':
                    document.execCommand('justifyRight', false, null);
                    break;
            }
            
            // Alternative method that works more reliably
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                let container = range.commonAncestorContainer;
                
                // Find the block-level parent element
                if (container.nodeType === 3) { // Text node
                    container = container.parentNode;
                }
                
                // Find the nearest block element
                while (container && container !== document.body) {
                    const tagName = container.tagName?.toLowerCase();
                    if (['p', 'h1', 'h2', 'h3', 'div', 'li', 'blockquote', 'pre'].includes(tagName)) {
                        container.style.textAlign = alignment;
                        break;
                    }
                    container = container.parentNode;
                }
            }
        }
        
        function setLineSpacing(spacing) {
            currentLineSpacing = parseFloat(spacing);
            
            // Apply to all editable content areas
            document.querySelectorAll('.editable-content').forEach(content => {
                content.style.lineHeight = currentLineSpacing;
                
                // Also apply to all child elements to ensure consistency
                const allElements = content.querySelectorAll('*');
                allElements.forEach(el => {
                    if (!el.style.lineHeight || el.style.lineHeight === 'inherit') {
                        el.style.lineHeight = 'inherit';
                    }
                });
            });
            
            // After changing line spacing, check for overflow
            setTimeout(() => {
                checkPageOverflow();
            }, 100);
            
            showStatus(`Line spacing set to ${spacing === '1' ? 'single' : spacing === '1.5' ? '1.5' : spacing === '2' ? 'double' : spacing + 'x'}`);
        }

        function insertImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = `<div class="image-container">
                        <img src="${e.target.result}" alt="Inserted image">
                        <div class="image-controls">
                            <button onclick="resizeImage(this, 'smaller')">-</button>
                            <button onclick="resizeImage(this, 'larger')">+</button>
                            <button onclick="deleteImage(this)">√ó</button>
                        </div>
                    </div>`;
                    document.execCommand('insertHTML', false, img);
                };
                reader.readAsDataURL(file);
            };
            input.click();
        }

        function insertTable() {
            const rows = prompt('Number of rows:', '3');
            const cols = prompt('Number of columns:', '3');
            if (rows && cols) {
                let table = '<table><tbody>';
                for (let i = 0; i < parseInt(rows); i++) {
                    table += '<tr>';
                    for (let j = 0; j < parseInt(cols); j++) {
                        table += i === 0 ? '<th>Header</th>' : '<td>Cell</td>';
                    }
                    table += '</tr>';
                }
                table += '</tbody></table>';
                document.execCommand('insertHTML', false, table);
            }
        }
        
        function insertTOC() {
            // Create a unique ID for this TOC
            const tocId = 'toc-' + Date.now();
            
            const tocHTML = `
                <div class="table-of-contents" id="${tocId}" contenteditable="false">
                    <h2>Table of Contents</h2>
                    <div class="toc-content">
                        <p style="text-align: center; color: #999;">Table of Contents will be generated here...</p>
                    </div>
                    <div class="toc-update-notice">Auto-updates when headings change</div>
                </div>
                <p><br></p>
            `;
            
            document.execCommand('insertHTML', false, tocHTML);
            
            // Update TOC immediately
            setTimeout(() => {
                updateAllTOCs();
            }, 100);
            
            showStatus('Table of Contents inserted!');
        }
        
        function updateAllTOCs() {
            // Find all TOC elements
            const tocs = document.querySelectorAll('.table-of-contents');
            
            tocs.forEach(toc => {
                updateTOC(toc);
            });
        }
        
        function updateTOC(tocElement) {
            // Collect all headings from all pages
            const headings = [];
            const containers = document.querySelectorAll('.document-container');
            
            containers.forEach((container, pageIndex) => {
                const pageNumber = pageIndex + 1;
                const content = container.querySelector('.editable-content');
                if (!content) return;
                
                // Find all headings
                const pageHeadings = content.querySelectorAll('h1, h2, h3');
                
                pageHeadings.forEach(heading => {
                    // Skip if it's inside a TOC
                    if (heading.closest('.table-of-contents')) return;
                    
                    const level = parseInt(heading.tagName.charAt(1));
                    const text = heading.textContent.trim();
                    
                    if (text) {
                        // Create a unique ID for the heading if it doesn't have one
                        if (!heading.id) {
                            heading.id = 'heading-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                        }
                        
                        headings.push({
                            level: level,
                            text: text,
                            id: heading.id,
                            pageNumber: pageNumber
                        });
                    }
                });
            });
            
            // Generate TOC HTML
            let tocHTML = '';
            
            if (headings.length === 0) {
                tocHTML = '<p style="text-align: center; color: #999;">No headings found. Add headings (H1, H2, H3) to generate table of contents.</p>';
            } else {
                headings.forEach(heading => {
                    tocHTML += `
                        <div class="toc-entry toc-level-${heading.level}">
                            <span class="toc-title">
                                <a href="#${heading.id}" class="toc-link" onclick="scrollToHeading('${heading.id}'); return false;">
                                    ${heading.text}
                                </a>
                            </span>
                            <span class="toc-dots"></span>
                            <span class="toc-page">${heading.pageNumber}</span>
                        </div>
                    `;
                });
            }
            
            // Update the TOC content
            const tocContent = tocElement.querySelector('.toc-content');
            if (tocContent) {
                tocContent.innerHTML = tocHTML;
            }
        }
        
        function scrollToHeading(headingId) {
            const heading = document.getElementById(headingId);
            if (heading) {
                heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // Highlight the heading briefly
                const originalBackground = heading.style.backgroundColor;
                heading.style.backgroundColor = '#ffeb3b';
                heading.style.transition = 'background-color 0.3s';
                
                setTimeout(() => {
                    heading.style.backgroundColor = originalBackground;
                }, 2000);
            }
        }
        
        // Add TOC update to content monitoring
        const originalSetupContentMonitoring = setupContentMonitoring;
        setupContentMonitoring = function() {
            originalSetupContentMonitoring();
            
            // Also monitor for heading changes
            if (contentObserver) {
                contentObserver.disconnect();
            }
            
            contentObserver = new MutationObserver((mutations) => {
                // Debounce overflow check
                clearTimeout(window.overflowTimeout);
                window.overflowTimeout = setTimeout(() => {
                    checkPageOverflow();
                    updateAllTOCs(); // Update TOCs when content changes
                }, 500);
            });
            
            // Observe all editable content areas
            document.querySelectorAll('.editable-content').forEach(content => {
                contentObserver.observe(content, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            });
        };

        function resizeImage(button, direction) {
            const img = button.parentElement.parentElement.querySelector('img');
            const currentWidth = img.offsetWidth;
            const newWidth = direction === 'larger' ? currentWidth * 1.2 : currentWidth / 1.2;
            img.style.width = newWidth + 'px';
        }

        function deleteImage(button) {
            button.parentElement.parentElement.remove();
        }

        function saveDocument() {
            saveAllPages();
            
            const pages = [];
            document.querySelectorAll('.document-container').forEach((container, index) => {
                const content = container.querySelector('.editable-content');
                if (content) {
                    pages.push({
                        pageNumber: index + 1,
                        content: content.innerHTML
                    });
                }
            });
            
            const doc = {
                pages: pages,
                pageCount: pages.length,
                timestamp: new Date().toISOString(),
                version: '2.0',
                format: 'US Letter',
                margins: '1 inch',
                lineSpacing: currentLineSpacing
            };
            
            // Save to localStorage
            localStorage.setItem('document-multipages', JSON.stringify(doc));
            
            // Also save to file for Claude to access
            const blob = new Blob([JSON.stringify(doc, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'document-' + Date.now() + '.json';
            a.click();
            
            showStatus(`Document saved! (${pages.length} page${pages.length > 1 ? 's' : ''})`);
        }

        function loadDocument() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    const doc = JSON.parse(e.target.result);
                    
                    // Clear existing pages except the first one
                    const containers = document.querySelectorAll('.document-container');
                    for (let i = containers.length - 1; i > 0; i--) {
                        containers[i].remove();
                    }
                    pageCount = 1;
                    
                    if (doc.version === '2.0' && doc.pages) {
                        // Load line spacing if available
                        if (doc.lineSpacing) {
                            currentLineSpacing = doc.lineSpacing;
                            // Update the dropdown
                            const spacingSelect = document.querySelector('select[onchange*="setLineSpacing"]');
                            if (spacingSelect) {
                                spacingSelect.value = doc.lineSpacing;
                            }
                            // Apply line spacing
                            setLineSpacing(doc.lineSpacing);
                        }
                        
                        // Load multi-page document
                        document.getElementById('document-content').innerHTML = doc.pages[0].content;
                        
                        // Create additional pages
                        for (let i = 1; i < doc.pages.length; i++) {
                            addNewPage();
                            const newContainers = document.querySelectorAll('.document-container');
                            const content = newContainers[i].querySelector('.editable-content');
                            if (content) {
                                content.innerHTML = doc.pages[i].content;
                            }
                        }
                        
                        showStatus(`Document loaded! (${doc.pages.length} pages)`);
                    } else if (doc.content) {
                        // Load old single-page format
                        document.getElementById('document-content').innerHTML = doc.content;
                        showStatus('Document loaded! (Legacy format)');
                    }
                    
                    // Re-setup monitoring
                    setTimeout(() => {
                        setupContentMonitoring();
                        checkPageOverflow();
                    }, 100);
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function exportAsHTML() {
            const content = document.getElementById('document-content').innerHTML;
            const fullHTML = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Exported Document</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        img { max-width: 100%; height: auto; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; }
    </style>
</head>
<body>
${content}
</body>
</html>`;
            
            const blob = new Blob([fullHTML], {type: 'text/html'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'document-' + Date.now() + '.html';
            a.click();
            showStatus('Exported as HTML!');
        }

        function exportAsMarkdown() {
            // Simple HTML to Markdown conversion
            let content = document.getElementById('document-content').innerHTML;
            content = content.replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\n\n');
            content = content.replace(/<h2[^>]*>(.*?)<\/h2>/gi, '## $1\n\n');
            content = content.replace(/<h3[^>]*>(.*?)<\/h3>/gi, '### $1\n\n');
            content = content.replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\n\n');
            content = content.replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n');
            content = content.replace(/<[^>]+>/g, '');
            
            const blob = new Blob([content], {type: 'text/markdown'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'document-' + Date.now() + '.md';
            a.click();
            showStatus('Exported as Markdown!');
        }

        function showStatus(message) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.style.display = 'block';
            setTimeout(() => {
                status.style.display = 'none';
            }, 2000);
        }

        // Auto-save every 30 seconds
        setInterval(() => {
            if (editMode) {
                saveAllPages();
            }
        }, 30000);
        
        // Check for overflow and create new pages
        function checkPageOverflow() {
            const containers = document.querySelectorAll('.document-container');
            
            containers.forEach((container, index) => {
                const content = container.querySelector('.editable-content');
                if (!content) return;
                
                // Get the actual content height vs available height
                const availableHeight = content.clientHeight;
                const contentHeight = content.scrollHeight;
                
                // Check if content overflows
                if (contentHeight > availableHeight + 2) { // Small buffer for rounding errors
                    // Create a temporary container to measure content
                    const tempDiv = document.createElement('div');
                    tempDiv.style.cssText = content.style.cssText;
                    tempDiv.style.position = 'absolute';
                    tempDiv.style.visibility = 'hidden';
                    tempDiv.style.height = 'auto';
                    tempDiv.style.width = content.clientWidth + 'px';
                    document.body.appendChild(tempDiv);
                    
                    // Clone and measure each child
                    const allNodes = Array.from(content.childNodes);
                    let currentHeight = 0;
                    let splitIndex = -1;
                    
                    for (let i = 0; i < allNodes.length; i++) {
                        const clone = allNodes[i].cloneNode(true);
                        tempDiv.appendChild(clone);
                        
                        const nodeHeight = tempDiv.scrollHeight - currentHeight;
                        
                        if (currentHeight + nodeHeight > availableHeight) {
                            splitIndex = i;
                            break;
                        }
                        currentHeight = tempDiv.scrollHeight;
                    }
                    
                    // Clean up temp div
                    document.body.removeChild(tempDiv);
                    
                    if (splitIndex >= 0) {
                        // Get or create next page
                        let nextContainer = container.nextElementSibling;
                        if (!nextContainer || !nextContainer.classList.contains('document-container')) {
                            nextContainer = addNewPage();
                        }
                        
                        const nextContent = nextContainer.querySelector('.editable-content');
                        
                        // Move overflowing content to next page
                        const nodesToMove = allNodes.slice(splitIndex);
                        const fragment = document.createDocumentFragment();
                        
                        nodesToMove.forEach(node => {
                            if (node.parentNode) {
                                fragment.appendChild(node);
                            }
                        });
                        
                        // Clear placeholder text if exists
                        if (nextContent.innerHTML.includes('Continue your content here')) {
                            nextContent.innerHTML = '';
                        }
                        
                        // Prepend to next page (in case it already has content)
                        nextContent.insertBefore(fragment, nextContent.firstChild);
                        
                        // Move cursor to the beginning of the moved content on the new page
                        if (nodesToMove.length > 0) {
                            // Focus the next page's content
                            nextContent.focus();
                            
                            // Place cursor at the beginning of the moved content
                            const range = document.createRange();
                            const selection = window.getSelection();
                            
                            // Find first text node in the moved content
                            let firstTextNode = null;
                            function findFirstTextNode(node) {
                                if (node.nodeType === 3 && node.textContent.trim()) {
                                    return node;
                                }
                                for (let child of node.childNodes) {
                                    const found = findFirstTextNode(child);
                                    if (found) return found;
                                }
                                return null;
                            }
                            
                            // Try to find a good cursor position
                            if (fragment.firstChild) {
                                firstTextNode = findFirstTextNode(nextContent);
                            }
                            
                            if (firstTextNode) {
                                range.setStart(firstTextNode, 0);
                                range.collapse(true);
                            } else {
                                // If no text node, place at start of content
                                range.selectNodeContents(nextContent);
                                range.collapse(true);
                            }
                            
                            selection.removeAllRanges();
                            selection.addRange(range);
                            
                            // Scroll the new page into view
                            nextContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                        
                        // Recursively check the next page
                        setTimeout(() => checkPageOverflow(), 100);
                    }
                }
            });
        }
        
        // Enhanced input monitoring for real-time page creation
        document.addEventListener('input', function(e) {
            if (e.target.closest('.editable-content')) {
                // Check for overflow more frequently during typing
                clearTimeout(window.overflowTimeout);
                window.overflowTimeout = setTimeout(() => {
                    checkPageOverflow();
                }, 100);
            }
        });
        
        // Check on Enter key press for immediate response
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && e.target.closest('.editable-content')) {
                const content = e.target.closest('.editable-content');
                const container = content.closest('.document-container');
                
                // Store cursor position before checking
                const selection = window.getSelection();
                const cursorAtEnd = selection.rangeCount > 0 && 
                    selection.getRangeAt(0).collapsed && 
                    selection.focusNode === content.lastChild;
                
                setTimeout(() => {
                    checkPageOverflow();
                    
                    // If we were at the end of the page and a new page was created
                    if (cursorAtEnd) {
                        const nextContainer = container.nextElementSibling;
                        if (nextContainer && nextContainer.classList.contains('document-container')) {
                            const nextContent = nextContainer.querySelector('.editable-content');
                            if (nextContent && !nextContent.textContent.trim()) {
                                // Focus on the new empty page
                                nextContent.focus();
                                const range = document.createRange();
                                range.selectNodeContents(nextContent);
                                range.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }
                        }
                    }
                }, 50);
            }
        });
        
        // Monitor content changes
        let contentObserver;
        function setupContentMonitoring() {
            // Disconnect existing observer if any
            if (contentObserver) {
                contentObserver.disconnect();
            }
            
            contentObserver = new MutationObserver((mutations) => {
                // Debounce overflow check
                clearTimeout(window.overflowTimeout);
                window.overflowTimeout = setTimeout(() => {
                    checkPageOverflow();
                }, 500);
            });
            
            // Observe all editable content areas
            document.querySelectorAll('.editable-content').forEach(content => {
                contentObserver.observe(content, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            });
        }
        
        // Handle paste events to check overflow
        document.addEventListener('paste', (e) => {
            setTimeout(() => {
                checkPageOverflow();
            }, 100);
        });
        
        // Save all pages
        function saveAllPages() {
            const pages = [];
            document.querySelectorAll('.document-container').forEach((container, index) => {
                const content = container.querySelector('.editable-content');
                if (content) {
                    pages.push({
                        pageNumber: index + 1,
                        content: content.innerHTML
                    });
                }
            });
            
            const doc = {
                pages: pages,
                pageCount: pages.length,
                timestamp: new Date().toISOString(),
                version: '2.0',
                lineSpacing: currentLineSpacing
            };
            
            localStorage.setItem('document-multipages', JSON.stringify(doc));
        }

        // Load autosave on startup
        window.onload = function() {
            // Try to load multi-page document first
            const multiPageDoc = localStorage.getItem('document-multipages');
            if (multiPageDoc) {
                const doc = JSON.parse(multiPageDoc);
                
                // Load first page
                if (doc.pages && doc.pages.length > 0) {
                    document.getElementById('document-content').innerHTML = doc.pages[0].content;
                    
                    // Create additional pages if needed
                    for (let i = 1; i < doc.pages.length; i++) {
                        addNewPage();
                        const containers = document.querySelectorAll('.document-container');
                        const content = containers[i].querySelector('.editable-content');
                        if (content) {
                            content.innerHTML = doc.pages[i].content;
                        }
                    }
                }
            } else {
                // Fallback to old autosave
                const autosave = localStorage.getItem('document-autosave');
                if (autosave) {
                    document.getElementById('document-content').innerHTML = autosave;
                }
            }
            
            // Setup monitoring after content is loaded
            setTimeout(() => {
                setupContentMonitoring();
                checkPageOverflow();
                updateAllTOCs(); // Update any existing TOCs
            }, 500);
        };
        
        function toggleMargins() {
            showMargins = !showMargins;
            document.querySelectorAll('.document-container').forEach(container => {
                container.classList.toggle('show-margins', showMargins);
            });
            showStatus(showMargins ? 'Margin guides shown' : 'Margin guides hidden');
        }
        
        function addNewPage(focusNewPage = false) {
            pageCount++;
            const pageWrapper = document.querySelector('.page-wrapper');
            const newPage = document.createElement('div');
            newPage.className = 'document-container' + (showMargins ? ' show-margins' : '');
            newPage.id = `page-${pageCount}`;
            newPage.innerHTML = `
                <div class="margin-guides"></div>
                <div class="page-info">Page ${pageCount} | US Letter (8.5" √ó 11")</div>
                <div class="editable-content" contenteditable="true" style="height: 9in; min-height: 9in; max-height: 9in;">
                </div>
            `;
            
            // Copy exact styles from first page to ensure consistency
            const firstPage = document.getElementById('page-1');
            if (firstPage) {
                const firstContent = firstPage.querySelector('.editable-content');
                const newContent = newPage.querySelector('.editable-content');
                if (firstContent && newContent) {
                    // Copy computed styles
                    const computedStyle = window.getComputedStyle(firstContent);
                    newContent.style.width = computedStyle.width;
                    newContent.style.lineHeight = currentLineSpacing;
                    newContent.style.fontSize = computedStyle.fontSize;
                    newContent.style.overflow = 'hidden';
                }
            }
            
            // Insert before the closing div of page-wrapper
            const lastPage = pageWrapper.querySelector('.document-container:last-of-type');
            lastPage.insertAdjacentElement('afterend', newPage);
            
            // Re-setup content monitoring for new page
            setupContentMonitoring();
            
            // Update any existing TOCs
            updateAllTOCs();
            
            // Focus on new page if requested
            if (focusNewPage) {
                const newContent = newPage.querySelector('.editable-content');
                if (newContent) {
                    newContent.focus();
                    // Place cursor at start
                    const range = document.createRange();
                    const selection = window.getSelection();
                    range.selectNodeContents(newContent);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Scroll to view
                    newPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
            
            showStatus(`Added page ${pageCount}`);
            
            return newPage;
        }
    </script>
</body>
</html>